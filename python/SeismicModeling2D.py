# -*- coding: utf-8 -*-
"""9_Sismograma.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1moAh7qtxs2wZinPYvMZ-5Htb8PQjG5Z0
"""

import numpy as np
import matplotlib.pyplot as plt
from numba import jit, njit, prange
import time


def init_fields(Nz,Nx,Nt):
  Up    = np.zeros([Nz,Nx])
  Uc    = np.zeros([Nz,Nx])
  Uf    = np.zeros([Nz,Nx])
  Seism = np.zeros([Nt,Nx])
  return Up, Uc, Uf, Seism

@jit(nopython=True,parallel=True)
def ricker(t,freq=60):
  pi     = np.pi
  td     = t - 2*np.sqrt(pi)/freq
  fcd    = freq/(np.sqrt(pi)*3) 
  source = (1 - 2*pi*(pi*fcd*td)*(pi*fcd*td))*np.exp(-pi*(pi*fcd*td)*(pi*fcd*td))
  return source

@jit(nopython=True,parallel=True)
def calculate_wavefield(Uf,Uc,Up,vp,dz,dx,dt):
  Nz,Nx = Uf.shape
  for i in prange(2,Nx-3): # parallel
    for j in prange(2,Nz-3): # parallel
      pxx = (-Uc[j,i+2] + 16*Uc[j,i+1] -30*Uc[j,i] + 16*Uc[j,i-1] - Uc[j,i-2] )/(12*dx*dx)
      pzz = (-Uc[j+2,i] + 16*Uc[j+1,i] -30*Uc[j,i] + 16*Uc[j-1,i] - Uc[j-2,i] )/(12*dz*dz)
      Uf[j,i]  = (vp[j,i]*vp[j,i])*(dt*dt)*(pxx + pzz) + 2*Uc[j,i] - Up[j,i]
  return Uf

def calculate_wavefield_serial(Uf,Uc,Up,vp,dz,dx,dt):
  Nz,Nx = Uf.shape
  for i in range(2,Nx-3):
    for j in range(2,Nz-3):
      pxx = (-Uc[j,i+2] + 16*Uc[j,i+1] -30*Uc[j,i] + 16*Uc[j,i-1] - Uc[j,i-2] )/(12*dx*dx)
      pzz = (-Uc[j+2,i] + 16*Uc[j+1,i] -30*Uc[j,i] + 16*Uc[j-1,i] - Uc[j-2,i] )/(12*dz*dz)
      Uf[j,i]  = (vp[j,i]*vp[j,i])*(dt*dt)*(pxx + pzz) + 2*Uc[j,i] - Up[j,i]
  return Uf

start_time = time.time()
#Parameters
dx = 5.
dz = 5.
dt = 0.001

L  = 10000
D  = 3000
T  = 1

x  = np.arange(0,L+dx,dx)
z  = np.arange(0,D+dz,dz)
t  = np.arange(0,T+dt,dt)

Nx = len(x)
Nz = len(z)
Nt = len(t)


print("Nx = %i ; Nz = %i and Nt = %i" %(Nx,Nz,Nt))
print("N  =      Nx . Nz . Nt   = %i  " %(Nx*Nz*Nt))

# To generate velocity model

vp        = np.zeros([Nz,Nx])
vp[0:int(Nz/4),:]= 1500
vp[int(Nz/4):int(Nz/2),:] = 2000
vp[int(Nz/2):Nz,:] = 3000

# plt.figure(figsize=(10,10))
# plt.imshow(vp,cmap='jet')
# plt.colorbar()
# plt.show(block=False)

# To generate the wavelet Ricker
freq = 60
source = ricker(t,freq)

# # Check wavelet
# plt.figure(figsize=(16,4))
# plt.plot(t,source)
# plt.grid()
# plt.show(block=False)

#Source and receiver position in grid points
sx = int((L/2)/dx)
sz = 2

rz    = 10
rx    = range(0,Nx)

# Check non-dispersion conditions
pointsWavelenth = 5
vp_min          = np.min(vp)
lamb_critical   = vp_min/freq
dx_critical     = lamb_critical/pointsWavelenth

# Check stability conditions
a_t = 1 + 2 + 1
a_s = 1/12 + 4/3 + 5/2 + 4/3 + 1/12

vp_max          = np.max(vp)
dt_critical     = dx_critical * np.sqrt(a_t/a_s)/vp_max

if (dt<=dt_critical and dx<=dx_critical):
  print("Stability and non-dispersion conditions ...... OK!") 
else:
  print("Problem!")
  print("dt_critical = %f dt = %f" %(dt_critical,dt))
  print("dx_critical = %f dx = %f" %(dx_critical,dx))

print("Courant number = %f" %(dt*vp_max/dx))
print("sqrt(a_t/a_s)  = %f" %np.sqrt(a_t/a_s))

# Allocating memory
Up, Uc, Uf, Seism = init_fields(Nz,Nx,Nt)

plt.figure(figsize=(10,10))
fig, ax = plt.subplots()

# time marching
for k in range(0,Nt):
  Uc[sz,sx] = Uc[sz,sx] - (dt*dt)*(vp[sz,sx]*vp[sz,sx])*source[k]

  Uf = calculate_wavefield(Uf,Uc,Up,vp,dz,dx,dt)
  # Uf = calculate_wavefield_serial(Uf,Uc,Up,vp,dz,dx,dt)

  Up = np.copy(Uc)
  Uc = np.copy(Uf)

  Seism[k,rx] = Uc[rz,rx]

  if (k%100 == 0):    
    print("step = %i" %k)
    ax.cla()
    ax.imshow(Uc)
    plt.pause(0.1)
    

plt.figure(figsize=(10,10))
perc = np.percentile(Seism,99)
plt.imshow(Seism,aspect='auto',cmap='gray',vmin=-perc,vmax=perc)
plt.show(block=False)

print("--- %s seconds ---" % (time.time() - start_time))
